1) Сделать понятные унифицированные модели - если использовать для каждого запроса разные модели,
то тупо запутаешься. Можно просто не заполнять некоторые поля (пароль и тд).
Сделать binding-модели (для общения внутри системы (создание сущностей, поиск)) и view-модели (для ответов на запросы)
Решение: Есть два типа моделей (Это не относится к работе с JWT и Identity) - <>Dto и <>ResponseDto. Первое отвечает за взаимодействие внутри приложения, второе - как модель представления
		
		Роль:
	0.1) Должна уже быть создана в БД. Никак, кроме как через БД, создана не может быть
	0.2) Имеет две Роли: ученик и учитель
	0.3) Привязка к ученикам необязательна

		Пользователь:
	1.1) Пользователь, так как будет загружаться из LDAP, создается первым. У него необязательно есть группа (если ее нет, то это учитель, иначе - ученик)
	1.2) Если пользователь ученик, то у него нет данных в User_Subject, связь с занятиями происходит через группу
	1.3) Если пользователь учитель, то у него нет группы, но есть уроки, к которым он прикреплен через User_Subject
	1.4) У пользователя обязательно есть Роль

		Группа:
	2.1) У группы могут быть необязательно Пользователи
	2.2) Занятия также не обязательны, они прикрепляются к уже созданной группе

		Помещение:
	3.1) У Помещения необязательно есть прикрепленные занятия

		Тип занятия:
	4.1) У Типа Занятия необязательно прикрепленные занятия

		Занятие:
	5.1) Создается и прикрепляется к Группе и Преподавателю 
	(но могут быть проблемы с Физкультурой)
	5.2) Обязательно заполняется Помещение и Тип занятия, также
	Week - номер недели по счёту
	Day - день недели
	Type - тип занятия (лаба, практика, лекция)
	Pair - номер занятия по счёту, всего девять
	IsDifference - флаг того, имеет ли расхождение
	данная пара с вновь скачанным расписанием
	5.3) При создании новой сущности надо проверять, существует ли такая
	же по данным параметрам - Week, Day, Type, Pair, Group, Place, Lesson

2) Сделать нормальное сохранение данных, скачанных парсером:
	2.1) Разобраться, зачем нужен флаг is_difference
		PS: Как проверять, отменили ли занятие или нет:
			1) Изначально ставится флаг isDifference = 1 - значит, что
			занятие только что внесено в таблицу.
			2) Затем при повторном парсинге расписания всем занятиям данной недели ставится isDifference = 0 - значит, что
			данное занятие уже было в БД. Происходит парсинг, вытаскиваются занятия и, если занятие с такими параметрами существует в БД, 
			то его флаг возвращают к isDifference = 1. Те занятия данной недели, у которых isDifference = 0 остался, удаляются,
			но со сравнением дня в занятии и сегодняшнего дня недели  --- Готово!
	2.2) Сделать не замену занятий, а внести какой-то флаг в сущность занятия, 
	если изменилось расписание, чтобы не удалять его --- Отстой, Закрыто  
	2.3) Сделать корректное сохранение скачанного расписания, чтобы ничего не ломалось:
		2.3.1) Можно сделать так, чтобы расписание у нас скачивалось только по преподавателям,
		которые уже есть в системе. Либо скачивать и создавать всех преподавателей.
	PS: Можно удалять занятия, которые еще не произошли, надо просто сделать на это проверку: Week+Day+PairNumber+Name
	Также расписание надо, скорее всего, скачивать только по тем учителям, что есть в системе, иначе сложно разрешить создание учителей
	Сначала необходимо сделать скачивание юзеров с лдапа, потому что иначе я не могу создавать учителей при парсинге расписания. Но, думаю,
	стоит пока сделать фейковые логины и пароли
3) Сделать синхронизацию с LDAP
	При скачивании данных создаются юзеры с полями + их группы. А уже к группам при парсинге прилинкуются занятия
	В сущность UserSubject записываются данные лишь тогда, когда пользователь хочет отметиться о присутствии на уроке 
4) Сделать работу сканирования qr-кода
5) Сделать разделение ролей
6) Сделать генерацию отчетов
